// 이진탐색 트리 //   구현이 빡세서 stl 사용하는것이 훨 씬 효율적이다.   만에하나 이진검색트리를 구현해서 풀어야 할 것 같다면.. ---> 이진검색트리를 사용하지 않는 풀이를 생각하자.
// https://blog.encrypted.gg/1013?category=773649
/*
    이진탐색 트리란?    
    일단 트리란 제일 꼭대기는 제외하고 위로 하나만 노드들이 연결되는 구조를 말합니다. 1. 트리에서 원소(노드)들은 정점이라고 부르며, 트리의 맨 꼭대기(위의 노드가 연결x)인 정점은 루트라고 부릅니다.
    2. 맨 마지막으로 아래의 노드가 연결되지 않는 정점들을 리프라고 부릅니다. 3. 또한 정점들을 잇는 선을 간선이라고 부릅니다.  4. 그리고 간선으로 위 아래가 연결된 관계를 자식,부모 관계라고
    부릅니다. 5. 어떤 한 장점에 대해 그 밑에 있는 장점과 간선을 모은것을 서브트리라고 부릅니다. (부분 트리라고 보면됨 (부분집합 처럼))  6. 트리의 높이는 트리의 그림을 봤을때 세로의 길이입니다.
        
    이진트리란 -> 각 노드의 자식이 2개 이하인 트리를 말합니다. (* 0,1,2개의 자식노드를 갖을 수 있는 트리) 자식이 2개 이하므로, 자식을 "오른쪽자식", "왼쪽자식"으로 나누어 부를 수 있습니다.

    <<< 이진검색트리 란 >>>    *** 이진트리 중에서 왼쪽 서브트리의 모든 값은 부모의 값보다 작고, 오른쪽 서브트리의 모든 값은 부모의 값보다 큰 이진트리를 말합니다.
    이진검색트리 https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCSkC8%2Fbtrj6dyZqcQ%2F9bFrjd95eBYsD1pVwmdsLK%2Fimg.png
    
    이진검색트리의 장점은 insert, erase, find, update을 모두 시간복잡도 O(logN)에 해결 할 수 있습니다.  앞의 연산을 할때, 쭉 위에서 아래로 왼쪽 또는 오른쪽 아래로 내려가면 되기 때문에 높이(logN)만큼의
    시간복잡도가 걸리게 되는 것 입니다. (* 이렇게만 보면 문제점이 있는것 같습니다. 만약 이진탐색트리가 만들어 질때, 서브트리가 쭉 아래로 연결된다면 (사선으로 쭉) 높이가 N이 될 수 있습니다. 즉, 시간복잡도가
    최악의 경우 N(선형시간)이 될 수 있습니다. 이렇게 되면 배열과 다를바가 없으므로, 이진탐색트리의 의미가 없어집니다. 따라서 이를 해결하기위해서  자가균형트리(Self-Balancing Tree)을 이용합니다. 대표적으로 
    AVL트리, Red Black트리가 있는데 그중 STL의 이진탐색트리는 Red Black 트리로 구현되어있습니다. )
    이렇게 보면 배열보다는 시간복잡도가 빠르므로 배열보다 효율적이고, 모든것들을 O(1)에 해결 할 수 있는 해시보다는 비효율적이라고 생각이 들고, 해시를 사용하고 싶은 생각이 듭니다.
    하지만, 해시에는 없는 이진탐색트릐의 이점이 있습니다. * "원소가 크기순으로 정렬된다는 점"입니다.
    해시라는 자료구조가 원소를 크기순으로 저장하는 자료구조가 아니기 때문입니다. 따라서 이진탐색트리의 경우 N보다 큰 최초의 원소를 logN에 알아낼 수 있지만, 해시는 불가능합니다.
    
    즉, *** insert, earse, find, update등이 빈번하면서, "원소의 대소와 관련한 성질이 필요할 경우" 이진탐색트리를 이용하면 효율적입니다.   ANCHOR



    < 이진검색트리의 STL >
    set, multiset, map, multimap 입니다.  즉, 앞에서본 해시의 stl에서 unordered만 뺀 것 입니다. (즉, 순서를 저장하는 자료형이란 것)

    set --->            원소들이 정렬되어서 저장된다. itertor을 prev(itr) <logN>, next(itr) <logN>, advance(itr,num) <numlogN> 로 이동시킬 수 있고, 해시와 다르게 정렬되어 있기 때문에 
                        lower_bound()함수를 사용할 수 있다. 그냥 모든 연산들이 O(logN)에 실행 시킬 수 있다.
    
    multiset --->       set과 다른점은 중복이 허용된다는 점이 다른 set입니다.    erase을 할 경우 같은 중복되는 것을 모두 지워버리므로, 조심하여서 사용하는 것이 좋습니다.

    map --->            key로 value를 찾는 STL


    ((( Tips )))
    1. lower_bound나 prev,next 이런것들으 사용해서 풀리는 문제라면 꼭 STL map,set으로 해결해야합니다.
    2. 평균적으로는 unordered_(set,map)이 set,map보다 빠르지만, 충돌이 얼마나 빈번한가에 따라서( 해시 구조이므로 ) unordered_map, unordered_set 는 속도저하가 발생할 수 있으므로, 안정적인 set,map을
       사용하는 것이 좋습니다. set,map은 평균적으로는 느릴지언정 항상 O(logN)이기 때문입니다.  (해시 구조를 사용하지 않으므로 충돌이 발생하지 않기에 안정적)    
    3. 이진검색트리는 O(logN)이지만, O(logN)들 중에서는 많이 느린 편이므로, 시간을 넉넉하게 생각하고 알고리즘을 구현하는 것이 좋습니다.    
*/