// Graph 그래프 //
/*
    그래프란?
    정점과 간선으로 이루어진 구조를 말합니다.
    ANCHOR 그리고 "차수(degree)"란 개념이 있는데,  각 정점에 대해서 간선으로 연결된 이웄한 정점의 개수를 말합니다.
    그래프는 최단경로찾기, 검색엔진에서 랭킹정하기와 같이 원소사이의 연결관계를 설정해야할떄 유용하게 활용되는 자료구조입니다.
    또한 간선의 방향의 유무에 따라서 무방향그래프, 방향그래프로 나뉩니다.

    ANCHOR "사이클이란?" 임의의 한점에서 출발하여서 자기자신으로 돌아올 수 있는 경로를 말합니다.
    사이클이 하나라도 있으면 순환그래프, 없을 경우 비순환그래프로 나눌 수 있습니다.
    주의해야 할점은 무방향그래프의 경우 연결되어 있기만 하다면 사이클이 존재하지만, 방향그래프의 경우 간선의 방향에 따라서 연결되어있는 경우에도 사이클이 나타나지 않을 수 있습니다.

    ANCHOR 완전 그래프
    모든 서로 다른 정점들이 간선으로 연결된 그래프를 말합니다. 즉, 정점이 총 6개라면, 각각 정점 마다 간선이 6개 존재하게 됩니다. (6개 이상일 수 있음...  같은 정점을 가는 간선이 여러개 일 경우)

    ANCHOR 연결 그래프
    모든 정점들이 연결된 그래프를 말합니다. 즉, 간선을 타고 정점과 정점을 경유해서 모든 정점으로 이동할 수 있는 그래프를 말합니다.

    *그래프는 꼭 연결되어 있어야 할 필요도 없고, 또 두 정점 사이의 간선이 반드시 1개 이하여야 할 필요도 없습니다.
    ANCHOR 루프(loop)
    한 정점에서 그 정점으로 연결된 간선   자기자신과 자기자신을 연결한 간선을 루프라고 합니다.

    ANCHOR 단순 그래프
    두 정점 사이의 간선이 1개 이하이고, 루프가 존재하지 않는 그래프를 우리는 단순 그래프라고 합니다.



    ANCHOR < 정의와 표현법 >

    1. 인접행렬   <<< 단, 간선이 1개 이하인 "단순 그래프"의 경우만 가능하다.
        ANCHOR 인접행렬로 그래프를 나타내면 정점이 V개이고, 간선이 E개일 떄, 어떤 두점이 연결되어 있는지 O(1)로 알 수 있고, 공간복잡도는 O(V^2)를 갖는다.
        EX) 1,2,3,4,5 정점이 있다고 하자.    (1은 연결됨.   0은 연결안됨을 의미한다.)
            (무방향 그래프)         무방향 그래프의 경우 인접행렬로 나타내면 대각선에 대하여 대칭이다.  (2,3) == (3,2) 므로
                1 2 3 4 5
              1 0 1 1 0 0
              2 1 0 0 0 0
              3 1 0 0 1 0
              4 0 0 1 0 0
              5 0 0 0 0 0

            (방향 그래프) -> 방향 그래프의 경우 대칭이 아니다.


    2. 인접리스트
        인접행렬고 비교해서 정점이 많고, 간선은 상대적으로 적게 써야할 경우 공간을 절약할 수 있는 방식입니다. 또한 경우에 따라서 인접행렬로 저장못하는 것을
        저장할 수도 있습니다.

        Ex) 정점이 1000000개 간선1개 ->   인접행렬은 무조건 100000^2 공간      인접리스트는 1개의 공간 필요    O(v^2)     O(v+e)

        구현방법은 각 정점에대한 배열을 만들고 이와 연결되어진 정점을 원소로 넣어주면 된다.  (ex)  vector[2].push_back(3);   2->3 간선이 존재한다는 의미.



    ANCHOR
                        인접행렬  vs  인접리스트
    공간복잡도            O(V^2)       O(V+E)

    정점 u,v가 연결됬는지  O(1)         O(min(deg(u),deg(v)))
    확인하는데 소요시간

    정점v와 연결된 모든    O(V)         O(deg(V))
    정점을 확인하는데 시간

    효율성         두점 연결여부        특정 정점에 연결된 모든 정점을 확인할때
                E, V^2 이 비슷        E <<<<<<<<<<<<<< V^2



    ANCHOR < BFS >
    BFS 알고리즘        다차원 배열에서 각 칸을 방문할 떄 너비를 우선으로 방문하는 알고리즘

    ANCHOR 그래프이론을 통한 BFS
        1. 시작하는 점을 큐에 넣고 방문했다는 표시를 남긴다.
        2. 큐에서 정점을 꺼내어 그 정점과 연결된 모드 정점들에 대해서 3번을 진행한다.
        3. 해당 정점을 이전에 방문했다면 아무 것도 하지 않고, 첫 방문이라면 방문했다는 표시를 남기고 해당 정점을 큐에 넣는다.
        4. 큐가 빌 때 까지 2번을 반복하낟.
        * 모든 정점이 큐에 최대 1번씩 들어가게 되므로 인접리스트에서 O(V+E), 인접행렬에서 O(V^2)의 시간복잡도를 갖는다.
          인접행렬에서 2번에 연결된 것들을 찾는데 O(V) 이 과정을 V번하므로, O(V^2)
    
    ANCHOR 그래프에서도 시작점에서 다른 모든 점으로의 최단거리르 찾을 때 BFS을 이용할 수 있습니다.   "단, 모든 간선의 길이가 동일 할 경우 BFS로 해결이 가능합니다."
           간선의 길이가 다를 경우 플로이드나 다익스트라와 같은 다른 알고리즘을 사용해야 합니다.
        
    ANCHOR 예외, 단순 그래프가 아닐 경우  https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FD0oSK%2FbtrmwQvGwdL%2FqFZekffgigIsimZG7y6UDk%2Fimg.png
        이런 식으로 그래프가 모두 이어져 있는 경우 가 아닐 경우,  for문을 돌면서 아직 방문하지 않은 정점을 찾아서 그 정점을 시작 정점으로 잡게끔 코드를 변형하면 됩니다.

    

    ANCHOR < DFS >
    DFS 알고리즘        다차원 배열에서 각 칸을 방문할떄 깊이를 우선으로 방문하는 알고리즘

    ANCHOR 그래프이론을 통한 DFS
        1. 시작하는 정점을 스택에 넣고 방문했다는 표시를 남긴다.
        2. 스택에서 정점을 꺼내어 그 정점과 연결된 모든 정점들에 대해서 3번을 진행한다.
        3. 해당 정점을 이전에 방문했다면 아무것도 하지 않고, 첫 방문이라면 방문했다는 표시를 남기고 스택에 넣는다.
        4. 스택이 빌 때 까지 2번을 반복한다.
        * 모든 정점이 스택에 최대 1번씩 들엉가게 되므로 인접리스트에서 O(V+E), 인접행렬에서 O(V^2)의 시간복잡도를 갖는다.

    ANCHOR 재귀적 DFS    vs    비재귀적 DFS
    비재귀 DFS의 경우 순회를 잘 수행하지만, 엄밀히 말해서 우리가 관념적으로 생각하는 DFS와 방문순서가 다릅니다. 따라서 단순히 방문순회하는 것이 아니라 DFS의 고유한 성질을 사용해서 문제를 해결해야 하는 경우
    앞에서 소개한 비재귀 DFS을 사용하면 안됩니다.
    또한 재귀 DFS의 경우는 갈 수 있는 곳이 여러 곳이라면 번호가 작은 것 부터 방문합니다.
*/
