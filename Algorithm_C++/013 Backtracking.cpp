// 백트랙킹 //
// 백트랙킹이란?   현재상태에서 가능한 모든 후보군을 따라 들어가면서 탐색하는 알고리즘  (해를 찾는 도중 막히면(끝나면) 되돌아가서 다시 해를 찾는 것) 최적화문제와 결정문제를 풀때 이용
// EX)  오목을 할때 다음 알을 두는것에 따라서 상황이 바뀌는데, 즉, 자신이 두는 위치에 따라서 그 뒤에 어떻게 될지 확인하고 둘 수 있는 모든 경우의 수를 시행해보고 결정하는 것도
//      벡트랙킹의 일종이라고 할 수 있다.

// *** 순열, 조합문제에서 사용하면 좋은 메소드   --->  next_permutation       #include <algorithm>을 하면 사용할 수 있다.

//  *** 아래의 문제는 백트랙킹 문제인데, 백트랙킹도 BFS와 마찬가지로 어느정도 틀이 정해져있으므로, 형태를 익히는 것이 좋다.
/*
https://www.acmicpc.net/problem/15649

N과 M (1) 
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	512 MB	48121	29447	19662	60.424%
문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.
*/
#include <iostream>

using namespace std;

int n,m;
int arr[10];                    // 출력할 수열을 저장하는 배열
bool isused[10]={false,};       // 사용했는지 유무

void backtracking(int k)                // 현재 k개까지 수를 택했음.
{                               
  if(k == m)                    // m개를 모두 택했으면
  {
    for(int i = 0; i < m; i++)
        cout << arr[i] << ' ';  // arr에 기록해둔 수를 출력
    cout << '\n';
    return;
  }

  for(int i = 1; i <= n; i++)           // 1부터 n까지의 수에 대해
  { 
    if(!isused[i])                      // 아직 i가 사용되지 않았으면
    { 
      arr[k] = i;                       // k번째 수를 i로 정함
      isused[i] = true;                 // i를 사용되었다고 표시
      backtracking(k+1);                        // 다음 수를 정하러 한 단계 더 들어감
      isused[i] = false;                // k번째 수를 i로 정한 모든 경우에 대해 다 확인했으니 i를 이제 사용되지않았다고 명시함.
    }
  }
}

int main(void)
{
  ios::sync_with_stdio(0);
  cin.tie(0);
  
  cin >> n >> m;

  backtracking(0);
  return 0;
}