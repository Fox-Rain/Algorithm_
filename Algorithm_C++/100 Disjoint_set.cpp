// Disjoint Set    분리집합 // 
/*
    A와 B가 친구관계이다.  B와 내가 친구관계이다.   --> A와 나는 B를 통해서 연결되어 있으므로 친구관계이다.    즉, 하나의 정점과 또다른 정점이 이어져있는지 확인하는 방법을 말한다.
    ANCHOR 물론 그래프탐색 (BFS,DFS)를 통해서 서로 연결되어 있는지 확인할 수 있지만 이 경우 정점이 추가될때마다 다시 그래프탐색을 해야한다는 점이 단점이다.
    즉 이러한 이어져있는지 확인하는 것을 그래프형태가 아닌, 그룹으로 표현한다면 소요되는 시간을 대푝 단축시킬 수 있다.
    내가 A와 친구를 먹었을때, 나는 A와 같은 그룹에 속하게 된다. 즉, 이제 다른 사용자와 친구관계(이어져있는지)는 속한 그룹만 비교하면 되는 것이다.


    <<< 분리집합    Disjoint Set >>>
    분리집합은 서로소집합이라고도 한다. 분리집합은 다음과 같은 특징을 지닌다. (전체집합 U, 분리집합 A,B)    
    A,B는 U의 부분집합이다.
    A,B는 공통원소를 갖지않는다.
    A,B의 합집합이 곧 전체집합이다.


    <<< Union_Find Algorithm >>>
    유니온 파인드는 이러한 분리집합을 구현하는 알고리즘으로, 각 그룹을 트리의 형태로 표현한다.
    각 노드마다 그 노드의 부모 노드 번호를 기록하여, 그래프를 위처럼 트리 구조로 나타낸다.
    이렇게 나타낸 트리는 무조건 최상위 노드인 루트노드를 갖게된다. 바로 이 루트노드를 통해서 그룹을 구별할 수 있다. (루트노드의 경우 부모가 없으므로 부모를 자기자신으로 설정한다.)

    다음과 같은 연산들이 필요하다.    1) 루트노드를 찾는 작업 (Find)    2) 두 트리를 병합하는 작업 (Union)      <<< 즉, 이 두 작업이 합쳐저서 Union_find 알고리즘이라고 한다.

    1) Find
    서로 같은 그룹인지 찾고싶은 원소 둘의 부모를 타고 올라가서 루트노드에 도달한뒤 두 루트노드가 같다면 같은 그룹,  다르다면 서로 다른 그룹이란 것을 알 수 있다.  그런데 이러한 로직으로 코드를 짤 경우 연결된 노드가 적다면 괜찮겠지만
    노드들이 많아지면 루트노드를 찾기 위해 거슬러 올라가는 연산이 무거워질 수 있다. 이를 해결하기 위해서 한노드에 find를 실행할때마다 그 노드의 부모 노드를 항상 루트노드로 만들어 준다면 효율적으로 루트노드를 찾도록 만들 수 있습니다.


    2) Union
    위에서 보았듯이 find의 시간복잡도는 루트노드까지 가는데 얼마나 많은 연산이 필요하냐가 중요하다. 즉, 시간복잡도는 트리의 높이에 따라 결정된다.
    다라서 union 연산 (그룹을 합치는 연산) 시 항상 높이가 낮은 트리를 높은 트리에 붙임으로써 시간복잡도를 줄일 수 있다.
    높이가 높은 트리가 낮은 트리에 붙을 경우, 합쳐진 트리의 높이가 더 많이 증가하기 때문이다.
*/

#include <bits/stdc++.h>

using namespace std;

int parent[100];

int Find(int x)
{
    if(x == parent[x])                      // 자기의 부모값과 자기자신이 같을 경우,  즉, 루트노드일 경우    그 자체를 리턴한다.
        return x;
    return parent[x] = Find(parent[x]);     // x가 루트노드가 아닐 경우,  부모노드에 대해서 find를 재귀실행한다. 추가로 게속해서 부모노드를 루트노드르 갱신한다.
}

void Union(int x, int y)
{
    x = Find(x);                // x의 루트노드를 찾아서 그 값으로 갱신
    y = Find(y);                // y의 루트노드를 찾아서 그 값으로 갱신

    if(x != y)                  // x,y가 서로 다른 그룹일 경우, 한쪽 그룹(트리)를 다른 그룹에 붙인다.
        parent[x] = y;
    else
        return;
}