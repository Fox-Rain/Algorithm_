// 이분 탐색 //
/*
    이분 탐색이란?   "정렬되어있는 배열"에서  특정 데이터를 찾기 위해서 모든 데이터를 순차적으로 확인하는 대신 "탐색범위를 절반으로 줄여가며 찾는 방법이다."
    이분 탐색은 시간복잡도가 O(logN) 으로 선형탐색 O(N) 보다 데이터가 커질수록 훨 씬 효율적인 탐색 알고리즘이다.
    ( 사실 상으로는 정렬이 필요하므로 정렬하는데 NlogN   이분탐색하는데 logN 하여서 정렬되지 않은 배열의 경우 총 O(NlogN + logN)의 시간복잡도를 갖는다. )


    << 이분탐색 >>
    void binary_Search(int arr[], int N, int target)    // 배열과, 그 배열의 크기를 인자로 받음
    {
        sort(&arr[0], &arr[N]);

        int st = 0;
        int ed = N - 1;
        while(st<=ed)                   *** AHCHOR  binary_search에서 while문은 st와 ed가 1차이가 나게 될 경우 무한루프에 빠지지 않는지 꼭 주의해야 합니다.
        {
            int md = (st + ed) / 2;
            if(arr[md]<target)
                st = md + 1;
            else if(arr[md]>target)
                ed = md - 1;
            else
            {
                cout << "Find" << '\n';
                return;
            }
        }
        cout << "Not Find" << '\n';
        return;
    }

    *** STL에도 binary_search() 메소드가 존재한다.    binary_search(시작주소, 끝주소+1, 찾을 원소)    단, stl은 이진탐색후 존재유무만 true false로 리턴해준다.
    *** 또한 이진탐색을 하기 위해서는 반드시 원소들이 "오름차순으로 정렬"이 되어있어야 한다.
    *** 이분탐색을 구현할 때, 꼭 start,end의 값들이 1차이가 날때 무한루프가 발생하는지 꼭 확인해야 한다. ( 실수가 많이 나오는 부분 )

    << Parametric Search >>
    parametric_search ---> 조건을 만족하는 최대/최소값을 구하는 문제(최적화 문제)를 결정문제로 변환하여서 이분탐색을 수행하는 방법을 말한다.

    (문제)
    https://www.acmicpc.net/problem/1654

    랜선 자르기  

    시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
    2 초	128 MB	103559	23859	15863	21.043%
    문제
    집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.

    이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)

    편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.

    입력
    첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.

    출력
    첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.

    < sol >
    이 문제의 경우 일반적으로 그리디 등 일반적인 알고리즘으로 풀어보려고하면 무지막지한 시간복잡도 때문에 풀리지 않습니다. 
    그런데 이문제는 특징을 가지고 있습니다. 바로 최대랜선의 길이를 늘이면 가능한 랜선의 개수가 줄어들고, 최대랜선의 길이를 줄이면 가능한 랜선의 개수가 늘어난다는 특징입니다.
    즉, 함수로 나타내게 되면 감소함수의 형태를 띈다는 것을 알 수 있습니다.   이때 우리는 parametric search 알고리즘을 사용할 수 있습니다. 즉, 최적화 문제를 -> 결정문제로 바꾸는 것입니다.

    (최적화문제) N개의 랜선을 만들 수 있는 랜선길이의 최대값은?
    (결정문제)  랜선의 길이가 X일 떄, N개의 랜선을 만들 수 있는가? YES or NO

    이 알고리즘의 경우에도 이분탐색의 시간복잡도가 현저하게 작다는 것을 이용하는 방식입니다.  이 문제의 경우 2^32 -1 의 범위에서 찾아야 하는데 이분탐색을 할 경우 32번의 연산만 하면 되기 때문입니다.
    즉, 시간복잡도는 반으로 쪼갠값 마다 N개의 랜선을 만들 수 있는지 확읺하면되므로, 확인하는데 연산 K번, 이분탐색 연산 32번으로 총 시간복잡도 O(32K) 즉, O(K)의 시간복잡도로 해결 할 수 있습니다.

    parametric search를 할때에는 최적화문제를 결정문제로 바꿀 수 있는지 생각해보고, 결정문제로 얻어낸 함수라 감소 또는 증가하는 함수인지 확인해야합니다. (감소, 증가 함수가 아닐 경우
    이분탐색 자체가 불가능하므로 parameetric search가 불가능하기 때문입니다.) 문제에 "최대최소 얘기가 있고, 범위가 매우 크거나, 시간복잡도를 log로 떨궈야 해결 할 수 있을 것 같은 때"에는
    parametric search 알고리즘을 고려해보는 것이 좋습니다.

    #include <bits/stdc++.h>

    using namespace std;

    int N, K;                // N 만들고 싶은 랜선의 수      K 가지고있는 랜선의 수    <--- 잘라서 N개 만들어야 함
    int line[10000];

    bool make_it(long long L)
    {
        long long cnt = 0;
        for (int i = 0; i < K; ++i)
            cnt += line[i] / L;
        
        if(cnt>=N)
            return true;
        else
            return false;
    }

    void parametric_search()
    {
        long long start = 1;
        long long end = INT_MAX;
        while (start < end)
        {
            long long mid = (start + end + 1) / 2;      // ANCHOR  무한루프를 막기위해서 start+end+1      * 아래 주석 참조 *
            if (make_it(mid))                           // mid길이의 랜선을 N개 만들 수 있으면
                start = mid;
            else                                        // mid길이의 랜선을 N개 만들 수 없다면
                end = mid - 1;
        }
        cout << start;
    }

    int main()
    {
        ios_base::sync_with_stdio(0);
        cin.tie(0);

        cin >> K >> N;
        for (int i = 0; i < K;++i)
            cin >> line[i];

        parametric_search();
        return 0;
    }
    // < 복기 >
    // 1. parametric serach
    // 2. 자료형의 주의하기  long long mid = (start+end+1) / 2;  여기서 long long을 쓴 이유는 start, end -> max ==> 2^31-1 로  둘이 더할 경우 int의 자료형을 넘을 수
    //    있기 때문에 overflow를 피하기 위해서 long long을 사용함.  overflow 조심하기.     *** -2^31 <= int <= 2^31-1 이다.
    // ANCHOR 부분의 무한루프를 막기위해서 start+end+1을 이용했다. 만약 start,와 end 가 1차이가 날 경우 Ex) 1,2   mid = (1+2)/2 = 1 이후 start=mid 가 들어가게 되면
    //        값이 똑같아 무한루프가 발생할 수 있다.  이 경우 start+end+1로 할경우 mid = (1+2+1)/2 = 2 로 start에 들어가면 2로바뀌기에 무한루프가 발생안하고
    //        end에 mid가 들어가더라도  end = min-1므로 1이 되기 때문에 무한루프가 발생하지 않습니다.



*/