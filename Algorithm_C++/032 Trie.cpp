// Trie // 
// https://blog.encrypted.gg/m/1059
/*
    ANCHOR Trie 알고리즘이란?
        문자열을 효율적으로 처리하기위한 트리구조를 말합니다.
        단어를 삽입 / 삭제 / 탐색할때 O(|S|)의 시간복잡도를 갖습니다.                             *|S|는 단어 S의 길이를 말합니다.
        단, 문자열을 그냥 배열에 저장하는 것 보다 최대 '4 x 글자 종륩'배 만큼 더 사용합니다. (예를 들어서 각 단어가 알파벳 소문자로만 되어있을 경우 104배 더 크기를 차지합니다.)
        그런데 이러한 이론적인 시간복잡도와 별개로 "실제로는 트라이가 해시, 이진검색트리에 비해 훨씬 느립니다." 일반적인 상황에서는 해시나 이진검색트리를 사용하는게 좋으나,
        "트라이의 성질"을 이용해야하는 문제가 여럿 존재하기 때문에 알아두어야합니다.

        TODO 트라이의 성질에 대해 살펴보면 트라이는 "이론적인 시간복잡도가 좋습니다." O(|S|) 즉, 기존에 단어가 얼마나 많이 저장되어있는지와 무관해게 무조건 삽입, 탐색, 삭제를 모조리 O(|S|)에
        처리할 수 있습니다.   해시, 이진검색트리 같은 알고리즘의 경우 상황에 따라 시간복잡도가 늘어날 수 있으나, 트라이의 경우 정직하게 어떠한 경우에도 O(|S|)입니다.
        TODO 이렇게 이론적으로 생각할때 트라이는 좋은 시간복잡도를 갖고있지만, 한편으로 트라이는 메모리를 많이 사용한다는 단점이 있습니다.
        그렇기에 메모리 사용이 병목이 될 수 있는 자료구조입니다.  물론 메모리를 줄일 수 있으나 그렇게 할 경우 시간복잡도가 늘어나는 구조입니다.



    ANCHOR Trie 구현
        ANCHOR Insert   (삽입)
            Ex) apple, apply, banana, ban, black을 삽입한다고 할경우 아래와 같이 트리가 생성됩니다.

                        a            b
                        p           a  l
                        p           n  a
                        l           a  c
                      e   y         n  k
                                    a
                    TODO 추가로 단어가 끝나면 끝났다는 표시를 해주어야합니다.
                         Ex) banana,  ban 의 경우 겹치므로 ban에서 n에 대해 끝났다는 표시를 하지 않을 경우 banana만 있다고 생각되지 ban이 있다고 생각하지 않기 때문입니다.


        ANCHOR Fetch    (검색)
            트리의 루트에서부터 내려가면서 검색합니다.
            찾으려는 단어의 구성요소가 트리를 내려가면서 차레대로있으면서 + 단어가 끝날때 단어가 끝난 표시 또한 존재할 경우 -> 단어가 존재한다는 것입니다.


        ANCHOR Erase    (제거)
            제거하려는 단어를 트리에서 일단 따라가 단어의 끝을 찾습니다.  이후  단어의 끝이라는 표시를 지웁니다.
            TODO 트라이 구조에서는 절대 정점을 제거하면 안됩니다. 제거할 경우 트라이의 구조가 망가져서 그 정점과 이어져있던 단어 또한 제거되는 것고 같기 때문입니다.
            TODO 그렇기 때문에 트라이는 삭제하더라도 정점이 메모리에 그대로 남아있기 때문에 메모리측면에서 매우 비효율적이고, 따라서 삭제가 자주 발생하는 환경에서 트라이는 적합하지 않습니다.


        트라이의 구조 EX)
                   (1)                                               *** TODO  char - 'a' 로 c_to_i 하면   e는 4    y는 24가 나오게 됩니다.
            (2) a        (8) b                  nxt[5][4] = 6                 *** nxt[정점번호][문자를 인덱스 번호로 변환한 것] = 존재하지 않는다면 -1을,  존재시에는 그 자식 문자가 할당받은 번호를 저장합니다.
            (3) p          .                    nxt[5][24] = 7                 ch[6] = true;    ch[7] = true   e,y는 단어의 끝이므로 ch에 true를 저장합니다.
            (4) p          .                    nxt[5][나머지] = -1
            (5) l          .
         (6) e  (7) y      .



    ANCHOR Trie에서 메모리 절약 방법
        일반적인 트라이의 경우 자식을 O(1)로 찾기위해서 nxt[MX][26] 와 같이 [26] 즉 나올 수 있는 모든 문자에 대해서 공간을 정점마다 할당해줍니다. 이 부분을 동적할당 (벡터, 연결리스트 등..) 으로 바꾸어준다면
        찾는 시간복잡도가 O(1)로 고정은 아니고 1~26으로 바뀌게 되나, 메모리는 줄일 수 있습니다.

        Ex)  nxt[MX][26];   대신에  vector<pair<int,int>> nxt[MX];  로 나타내고   pair < 문자를 번호로 바꾼값, 할당된 번호 > 로 저장하는 방식입니다.
        에를 들어서 각 정점마다 연결되는 문자의 개수가 1개인 경우라면 메모리를 1/26로 줄이는 효과가 있습니다.

        보통 트라이로 푸는 것을 의도하고 낸 문제의 경우 고정된 크기의 배열로 잡아도 메모리 초과가 발생하지 않도록 제한을 두는 일이 대부분이지만, 간혹 문자의 종류가 너무 많다던가 하는 이유로 메모리를 계산했을 때
        초과가 발생할 것 같다 싶으면 여기 나와있는 방법과 같이 자식 정점들을 다른 방법으로 저장하는 것을 고려해볼 수 있습니다.

        < 메모리 절약 방법 >  --- 저장하는 방법에 따른 시간복잡도와 공간복잡도 예시들 (아래참고)      * BOJ 14425 기준으로 작성된 표입니다.
        https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbYUEaG%2FbtrLwA3dMRs%2FlnCpwSQPHgZfkun7UiAI7k%2Fimg.png


    ANCHOR Trie가 특히 이분검색트리, 해시보다 느린 이유.
        일단 첫번째로 일반적인 연산보다 메모리에 접근하는 연산이 더 느립니다. 그런데 이러한 메모리의 접근하는 연산이 트라이의 경우 훨씬 많습니다.
        두번째로 트라이 구조의 경우 메모리를 많이 차지합니다. 즉 따라서 메모리에 접근할때 O(1)으로 접근한다해도 하드웨어적인 cache hit rate가 굉장히 나쁩니다.
        위와같은 이유로 트라이의 경우 이론적 시간복잡도보다 더 느립니다,
*/

#include <bits/stdc++.h>

using namespace std;

const int root = 1;                     // 루트노드번호
int unused = 2;                         // 새로운 정점이 추가될때마다 갱신되는 변수
const int MX = 10000 * 5000 + 5;        // 최대 등장 가능한 글자의 수 (Ex) 예를들어서 최대 길이가 500인 단어가 10000개까지 들어올 수 있다면 10000 * 5000 근데 추가로 시작 root 가 0이 아니므로 여유로 +5를 주었습니다.
bool chk[MX];                            // 해당 정점이 단어의 끝인지를 저장하는 배열
int nxt[MX][26];                        // 각 정점에서의 자식 정점의 번호를 저장하는 배열      자식정점을 순간마다 O(1)로 알 수 있다는 장점이 있지만 메모리를 아주 많이 차지한다는 단점이 존재합니다. (여기선 알파벳 26 [26] 사용)

// ANCHOR    char (여기서는 소문자 알파벳만 받는다.) 를 각각에 맞게 숫자로 바꾸어주는 함수.  (인덱스로 쓰기 위해서)
int c_to_i(char c)                      
{
    return c - 'a';
}

// ANCHOR    단어를 삽입하는 함수
void insert(string& s)
{
    int cur = root;                                     // 현재 보고 있는 정점을 의미하는 것으로 처음은 root로 초기화해줍니다.
    for(auto c : s)
    {
        if(nxt[cur][c_to_i(c)] == -1)                   // 단어의 문자가 자식으로 아직 연결 안되어 있을 경우     ->  자식으로 연결하고 unused +1
            nxt[cur][c_to_i(c)] = unused++;
        cur = nxt[cur][c_to_i(c)];                      // 현재 보고있는 정점을 갱신해준다.
    }
    chk[cur] = true;                                    // for문이 다 끝났다면 단어의 끝이므로 chk[cur] = true로 단어의 끝임을 표시해줍니다.
}

// ANCHOR    단어가 존재하는지 확인하는 함수
bool find(string& s)                    
{
    int cur = root;
    for (auto c : s)                                    // 트리안에 단어의 문자들일 다 순서대로 들어있는지 확인.
    {
        if(nxt[cur][c_to_i(c)] == -1)
            return false;
        cur = nxt[cur][c_to_i(c)];
    }
    return chk[cur];                                    // 순서대로 들어있어도 만약 단어의 끝이 False라면 false.    단어의 끝까지 True여야만이 true가 리턴된다.
}

// ANCHOR    단어를 제거하는 함수
void erase(string& s)
{
    int cur = root;
    for(auto c :s)
    {
        if(nxt[cur][c_to_i(c)]== -1)                    // 자식이 존재안할 경우 -> 단어가 존재하지 않는다는 것이므로 바로 종료 (return;)
            return;
        cur = nxt[cur][c_to_i(c)];
    }   
    chk[cur] = false;                                   // 제거는 그냥 단어의 끝값을 true -> false로 바꾸어주면 됩니다.  (정점을 제거할 경우 트리가 망가질 수 있으므로 정점은 그대로 놔둡니다.)
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    for (int i = 0; i < MX;++i)                 // 일단 nxt를 모두 -1로 초기화합니다.           nxt == -1 해당하는 정점의 자식이 없다는 의미.
        fill(&nxt[i][0], &nxt[i][26], -1);

    return 0;
}