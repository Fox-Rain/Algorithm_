< 1.    간선문제의 BFS/DFS >
간선문제의 DFS/BFS의 경우 간선이 주어질 때 (방향이 없는 간선일 경우)  꼭 둘다 정보를 주어주어야 한다.
EX) 1 3 이 주어질 경우  --->  1 3     3 1 이렇게 둘을 저장해야한다. 각각 [1], [3]에 넣어야한다.




< 2.    배열을 복사하는 함수 copy() >
#include <algorithm>

copy(배열의 첫 시작주소, 마지막주소, 복사한 것을 넣을 배열의 첫 주소);
copy(vec.begin(),vec.end(), copyvec.begin());           <--- vector의 경우




< 3.    cin 과 getline() >    ANCHOR
* cin의 경우    --->  '\n' 개행문자를 버퍼에서 받아오지 않습니다.
* geline의 경우 --->   default라고 가정할 시  '\n' 개행문자를 만나면 버퍼에서 받아오므로 버퍼에 '\n'이 남지 않습니다.

따라서 아래와 같은 코드에서는 cin.ignore() 을 통해서 개행문자를 읽어들여서 없애야 합니다.   ( *** cin.ignore() 은 버퍼의 맨처음 문자 1개만 지웁니다.)

int num;
std::cin >> num;

cin.ignore();       <<--- *** 여기서 위에서 발생한 개행문자를 읽어 들이므로 아래에서 정상적으로 string을 받을 수 있게 됩니다.    ANCHOR
                              cin.ignore() 이 없을 경우 str은 개행문자를 바로 읽고 종료되게 됩니다.
string str;
getline(cin,str);

< 추가예시   cin.ignore() 과 버퍼가 어떻게 작동하는지 >
    #include <iostream>
    using namespace std;
    int main(void)
    {
        string s;
        
        for(int i=0;i<3;i++)
        {
            cin.ignore();
            getline(cin,s);
            cout << s << endl;
        }
        return 0;
    }

    입력한 문자열의 첫번째 문자가 삭제되어 출력됩니다.

    (입력)              (결과)
    1234                234
    1234                234
    1234                234




< 4.    회전 알고리즘 >    ANCHOR
반시계방향 회전 알고리즘
현재 돌리려는 것의 세로 개수가 R, 가로 개수가 C인 직사각형일 때,   cur[i][j]은     nxt[j][세로(R)-i-1] 로 바뀐다.

시계방향 회전 알고리즘
위와 반대로 cur[j][세로(R)-i-1]은 nxt[i][j]로 바뀐다.




< 5.    STL deque >
deque의 경우  stack+queue 구조로써 앞과 뒤 둘다 push,pop이 가능하다.  + indexing  인덱싱을 통해서 접근이 가능하다는 장점도 있다.




< 6.    next_permutation >    ANCHOR
#include <algorithm> 의 next_permutation을 쓰기전에  next_permutation을 쓸 배열을 꼭 오름차순으로 정렬되어있어야 제대로 작동한다.
permutation의 구현이 배열(vector)가 내림차순으로 정렬될 경우 더이상 순열을 바꾸지 않도록 구현되어있기 때문이다.
따라서 next_permutation 구한다면 무조건 배열이 오름차순이어야 한다.




< 7.    6C3, 4C2 와 같이 절반을 뽑는 조합의 경우  next_permutation을 이용해서 중복피하는 법 >    ANCHOR
next_permutation()의 경우 순열을 뽑아낼때  아래와 같이 대칭적으로 뽑아낸다.  따라서 절반(N/2)에서 next_permutation을 종료해주면 중복을 피할 수 있다.

Ex)             0011
                0101
                0110               << 여기서 끊으면 된다. 보다시피 대칭적이다.
                1001    
                1010
                1100




< 8.    iterator을 사용할 때 erase로 원소를 지울 때 주의사항 >    ANCHOR
iterator을 사용하면서 erase를 하는 메소드의 경우 리턴값으로 방금 지운곳의 iterator을 리턴한다.
따라서 지우게 되는 경우에는 iterator의 경우 한칸씩 당겨지므로, iter을 증가시지키 않고 그대로 유지 시켜야 한다.  즉, 아래와 같이 코드를 적어주어야한다.

vector<int> vec;

vector<int> itertor:: iter;
for ( iter=vec.begin(); iter!=vec.end();) 
{
    if (삭제의 조건문) 
        iter = vec.erase(iter);
    else 
        iter++;
}




< 9.    map 의 경우 찾기/삽입/삭제가 O(logN)이다 >    ANCHOR
내부적으로 red-black-tree로 구현됨. 찾을때 시간복잡도가 logN으로 매우 효율적이다. 단, random access를 지원하지 않는다.




< 10.    for문을 돌릴때 주의사항 >    ANCHOR
Ex)
    for(int i=0;i<Q.size();++i)  <--- 이러한 코드의 경우 문제가 발생할 여지가 있다.  왜나햐면 내부 루프에서 Q.size() 값이 바뀔 여지가 있는 코드가 실행되기 때문이다.
    {
        if(Q[i]==value)          <--- 이러한 if문에서 pop하게 되면 Q.size()가 줄어들게 되고 의도했던것과 다르게 루프가 돌다가 멈출 수 있다.
            Q.pop_back();
    }

해결코드)
    int Qs = Q.size();
    for(int i=0;i<Qs;++i)        <--- 해결방안으로 이런식으로 Q.size()와 같이 변할수 있는 부분은 상수로 처음에 받아서 루프에 넣어주는 식으로 바꾸면 된다.
    {
        if(...)
            ....
    }




< 11.    max(),min() 함수 >
#include <algorithm> 헤더에 존재하는 함수 max,min()은 3개이상의 인수를 넣으려고 할때  배열로 넣어주어야한다.  Ex) max({x,y,z}) (o)   max(x,y,z) (x)




< 12.    Prefix_sum (구간 합) Algorithm >
간혹가다가 어디서부터 어디까지의 합을 구하라는 문제가 있는데, 그경우 하나하나 더해서 구할 경우 O(M-N)의 시간복잡도를 갖게된다. (N~M까지의 합)
여기에 + 로 테스트 케이스가 여러개 주어지거나 할 경우, 시간초과가 발생할 수 있는데, 이경우 처음에만 테이블을 만들어주면 O(1)로 구간합을 구할 수 있는 prefix-sum 알고리즘을 사용하면 된다.
즉, 값을 받아서 저장하는 것이 아닌, 그전까지의 값의 합 + 값을 배열에 저장하는 것이다.   -> 이렇게 테이블을 만들고 난 뒤에는 table[M]-table[N-1] 로 구간합을 구할 수 있으므로, O(1)의 시간 복잡도를 갖게된다.




< 13.    소숫점 자릿수 얼마나 출력할지 정하기 >    ANCHOR
#include <iostream>

cout<<fixed;
cout.precision(num);   <<<-- num만큼 소수점 자릿수가 출력되게 된다.




< 14.    vector<bool> 의 효율성 >    ANCHOR ---> *** 효율성면에서 bool arr[] 보다 vector<bool>이 낫다.
일반적으로 bool 타입의 경우 true, false 로  1비트만으로 나타낼 수 있는 자료형이나, 1byte(8bits)의 자리를 차지한다.  이 경우 비효율적일 수 있다.
그런데 vector의 경우 bool을 C구조체의 비트필트처럼 1비트만 사용한다.  따라서 bool arr[] 보다는 vector<bool>을 사용하는 것이 더 cache hit rate, 메모리 적인 부분에서
더 효율적이므로  vector을 사용하자
(단, vector<bool>의 경우 1bit씩만 사용하므로, 주소로의 참조(?) 할 경우 문제가 발생할 수 있다고 한다.)




< 15.    BFS를 사용하는 문제에서의 "동시" >    ANCHOR
BFS()를 사용하는데에서의 동시에 찾는다, 동시에 확장한다, 동시에 이동한다 등의 내용이 있을 경우에는 BFS의 동시에 돌아가야하는 것들의 원소들을 처음에 모두 넣고 BFS을 돌려야 한다.
만약 각각 따로따로 한개씩 넣고 각각 BFS을 돌리게 된다면, 먼저 돌린 BFS에서 방문했다는 이유로 뒤에 BFS는 방문하지 못하거나 하는 경우가 발생할 수 있다.   즉, 따라서 동시에라는 키워드가 주어진 BFS문제의 경우
꼭 BFS에 원소를 어떻게 넣고 시작해야할지 먼저 고민해야한다.     EX) baekjoon 16920 




< 16.    상황에 따라서 for문을 반대로 돌리면 시간복잡도가 줄어드는 경우도 많다 >    ANCHOR
baekjoon 11501 Greedy 문제
baekjoon 2847 Greedy 문제




< 17.    vector.size()에서 Overflow by unsigned int >    ANCHOR
for(int i=vec.size()-1; i<5; ++i)        <-- 주의할 점이 vector size()함수의 리턴형은 unsigned int이다. 따라서 0보다 작은 값이 될 경우 overflow가 발생해서
{                                            무한루프에 빠질 수 있으므로 범위 설정에 주의해야한다.
    ....                                        
}




< 18.    do_while과 같이 원본을 가지고 여러번 돌려봐야하는 경우 >    ANCHOR
꼭, 여러번 돌리기전에 원본을 temp로 copy하여서 저장해두고, do_while을 돌릴 때 마다 원본을 다시 집어넣어주는 식으로 구현해 주어야 하는 것을 잊지 말자.




< 19.    큰 크기의 배열을 선언할 때 >    ANCHOR    ( 10^5이상의 큰 크기의 배열을 선언할 때에는 전역으로 선언해야한다. )
큰 크기의 배열을 선언할 때,   함수내부에서 선언하는 경우 10^5승이 최대인 것 같다.  왜냐하면 함수 내부에서 선언되는 경우 메모리가 스택에 저장되게 되는데, 크기가 클 경우 문제가 생기기 때문이다.
( 문제점 1. 수행속도가 느려질 수 있다.    2. 이론적으로 스택--지역 자동변수가 저장되는 영역은 크기 제한이 없지만, 시스템에 따라서 효율을 높이기 위해 자체적으로 제한하기도 한다.  <-- 이경우의 문제가 바로 함수
        내부에서 매우 큰 배열을 선언할 경우 segment fault가 뜨는 이유이다.)
따라서 큰 배열을 선언해야 하는 경우, 바깥에 전역으로 선언해 주는 것이 바람직하다.




< 20.    역추적 >    ANCHOR
예를 들면 가장 짧은 수열의 길이를 구하고, 그중 수열을 하나 출력하라는 서브테스크 문제가 있을 경우   -> privious배열을 통해서 역추적하는 방법이 있다.
즉, 배열의 선택되는 원소 idx마다 그전의 idx을 저장하여서  역으로 거슬러서 추적하는 방법이다.         Ex) baekjoon 14002




< 21.    2차원 이상의 배열을 인자로 전달할 경우 >
void func( ... )   인자로 전달할 경우  int arr[][size] 이런식으로 끝의 크기는 주어주어야하며,  주소만으로는 배열의 크기를 알 수 없으므로, 열,행의 크기를 같이 전달해주는 것이
좋다.




< 22.    이분탐색에서의 시간복잡도를 줄이는 아이디어 >    ANCHOR
이분탐색의 경우 logN으로 시간복잡도가 현저히 작다는 것을 이용하여서 시간복잡도를 줄이는 자주쓰이는 아이디어가 있다.
일반적으로 선형시간을 갖거하는 연산을 하나의 배열로 만들어서 이분탐색으로 넘기는 식으로 구현하는 것이다.  baekjoon 2295




< 23.    Parametric Search >    ANCHOR  조건) 결정문제로 바꾸었을때, 함수가 감소함수거나 증가함수여야만 한다.
"최적화문제"를 "결정문제"로 바꾸어 수행하는 알고리즘
범위가 기하급수적으로 크거나, 다른 알고리즘으로 풀어야할 경우 시간복잡도가 매우크고, 결정문제로 문제를 바꾸었을때, 함수가 감소 또는 증가 함수일 경우 이 알고리즘을 고려해볼 필요가
있다.

EX)    N개의 랜선을 만들 수 있는 랜선길이의 최대값은?  --->   X길이의 랜선을 N개 만들 수 있는가?     <<< 랜선길이의 범위는 매우크다. ex) int 범위
       int범위는 무지하게 크다, 그러나 이분탐색을 할 경우 32번의 연산만에 찾아낼 수 있다.




< 24.    upper_bound, lower_bound >    ANCHOR   " 이분탐색 "
binary_search 이분탐색을 통해 구현되서 원하는 값이 존재하는 첫번째위치의 인덱스를 리턴하는 lower_bound함수와, 원하는값보다 큰 수중 가장 작은수의 인덱스를 리턴하는 upper_bound함수이다.
파라미터로는 탐색하려는 배열의 첫주소와 마지막원소+1의 주소, 그리고 target값을 받는다.  만약 target값이 배열에 존재하지 않는다면 배열의 end 즉, 마지막원소+1을 리턴한다.
이분탐색 문제중에서 여러 답이 있을 경우 binary_Search의 경우 참 거짓만 알 수 있는데 upper_bound()-lower_bound()을 이용하면 원하는 값의 수까지 알아낼 수 있어서 편리하다.




< 25.     >




